//
//  GlossaryEntry.swift
//  TwinAct Field Companion
//
//  Data model for DPP Jargon Buster glossary terms.
//  Provides consumer-friendly explanations for technical EU Digital Product Passport terminology.
//

import Foundation

// MARK: - Glossary Entry

/// A glossary entry with a consumer-friendly explanation of a DPP/technical term.
public struct GlossaryEntry: Codable, Identifiable, Sendable, Hashable {
    /// Unique identifier (snake_case key, e.g., "carbon_footprint")
    public let id: String

    /// Display title (e.g., "Carbon Footprint")
    public let title: String

    /// Simple definition for a 5th-grader (max 25 words)
    public let simpleText: String

    /// Real-world analogy to help understanding
    public let analogy: String?

    /// SF Symbol name for visual display
    public let icon: String

    /// Category for grouping and filtering
    public let category: TermCategory

    /// Related term IDs for cross-referencing
    public let relatedTerms: [String]?

    /// IDTA semantic ID if linked to a standard spec
    public let semanticId: String?

    /// Source of this glossary entry
    public let source: Source

    public init(
        id: String,
        title: String,
        simpleText: String,
        analogy: String? = nil,
        icon: String,
        category: TermCategory,
        relatedTerms: [String]? = nil,
        semanticId: String? = nil,
        source: Source = .local
    ) {
        self.id = id
        self.title = title
        self.simpleText = simpleText
        self.analogy = analogy
        self.icon = icon
        self.category = category
        self.relatedTerms = relatedTerms
        self.semanticId = semanticId
        self.source = source
    }

    // MARK: - Hashable

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }

    public static func == (lhs: GlossaryEntry, rhs: GlossaryEntry) -> Bool {
        lhs.id == rhs.id
    }
}

// MARK: - Term Category

/// Categories for organizing glossary terms.
public enum TermCategory: String, Codable, Sendable, CaseIterable {
    /// Carbon footprint, recycling, circular economy
    case sustainability

    /// State of Health, impedance, capacity
    case battery

    /// ESPR, EPR, due diligence
    case compliance

    /// Firmware, protocols, specifications
    case technical

    /// Batch, serial, production
    case manufacturing

    /// Human-readable display name
    public var displayName: String {
        switch self {
        case .sustainability: return "Sustainability"
        case .battery: return "Battery"
        case .compliance: return "Compliance"
        case .technical: return "Technical"
        case .manufacturing: return "Manufacturing"
        }
    }

    /// SF Symbol icon for this category
    public var icon: String {
        switch self {
        case .sustainability: return "leaf.fill"
        case .battery: return "battery.100.bolt"
        case .compliance: return "checkmark.shield.fill"
        case .technical: return "cpu.fill"
        case .manufacturing: return "hammer.fill"
        }
    }

    /// Color name for visual theming
    public var colorName: String {
        switch self {
        case .sustainability: return "green"
        case .battery: return "yellow"
        case .compliance: return "blue"
        case .technical: return "purple"
        case .manufacturing: return "orange"
        }
    }
}

// MARK: - Source

extension GlossaryEntry {
    /// Source of a glossary entry.
    public enum Source: Codable, Sendable, Hashable {
        /// From bundled glossary.json
        case local

        /// Previously fetched LLM response, cached locally
        case cached

        /// Dynamically generated by LLM
        case llm(provider: String)

        // MARK: - Codable

        private enum CodingKeys: String, CodingKey {
            case type
            case provider
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let type = try container.decode(String.self, forKey: .type)

            switch type {
            case "local":
                self = .local
            case "cached":
                self = .cached
            case "llm":
                let provider = try container.decode(String.self, forKey: .provider)
                self = .llm(provider: provider)
            default:
                self = .local
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            switch self {
            case .local:
                try container.encode("local", forKey: .type)
            case .cached:
                try container.encode("cached", forKey: .type)
            case .llm(let provider):
                try container.encode("llm", forKey: .type)
                try container.encode(provider, forKey: .provider)
            }
        }

        /// Human-readable description
        public var displayName: String {
            switch self {
            case .local:
                return "Official Definition"
            case .cached:
                return "AI Generated (Cached)"
            case .llm(let provider):
                return "AI Generated (\(provider))"
            }
        }

        /// Whether this is an AI-generated entry
        public var isAIGenerated: Bool {
            switch self {
            case .local:
                return false
            case .cached, .llm:
                return true
            }
        }
    }
}

// MARK: - Identified Term

/// A term identified within a text block, with its position for highlighting.
public struct IdentifiedTerm: Sendable, Hashable {
    /// The term ID that was matched
    public let termId: String

    /// The matched text as it appears in the source
    public let matchedText: String

    /// Range in the original string
    public let range: Range<String.Index>

    public init(termId: String, matchedText: String, range: Range<String.Index>) {
        self.termId = termId
        self.matchedText = matchedText
        self.range = range
    }

    // MARK: - Hashable

    public func hash(into hasher: inout Hasher) {
        hasher.combine(termId)
        hasher.combine(matchedText)
    }

    public static func == (lhs: IdentifiedTerm, rhs: IdentifiedTerm) -> Bool {
        lhs.termId == rhs.termId && lhs.matchedText == rhs.matchedText
    }
}

// MARK: - Glossary Response

/// Response structure for LLM-generated glossary explanations.
public struct GlossaryLLMResponse: Codable, Sendable {
    public let title: String
    public let simpleText: String
    public let analogy: String?
    public let icon: String?

    /// Convert to a GlossaryEntry
    public func toEntry(
        id: String,
        category: TermCategory,
        provider: String
    ) -> GlossaryEntry {
        GlossaryEntry(
            id: id,
            title: title,
            simpleText: simpleText,
            analogy: analogy,
            icon: icon ?? "questionmark.circle.fill",
            category: category,
            source: .llm(provider: provider)
        )
    }
}

// MARK: - Glossary File Structure

/// Structure for the bundled glossary.json file.
public struct GlossaryFile: Codable, Sendable {
    public let version: String
    public let lastUpdated: String
    public let entries: [GlossaryEntry]

    public init(version: String, lastUpdated: String, entries: [GlossaryEntry]) {
        self.version = version
        self.lastUpdated = lastUpdated
        self.entries = entries
    }
}
